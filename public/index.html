<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÂºπÂºπÁ≥ñÂØπÊàòÊ∏∏Êàè</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <script src="https://cdn.jsdelivr.net/npm/@multisynq/client@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Exo+2:wght@300;400;700&display=swap');

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1a2e 30%, #16213e 70%, #0f0f23 100%);
            font-family: 'Exo 2', sans-serif;
            color: #00ffff;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(circle at 20% 50%, rgba(0, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 0, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(0, 255, 150, 0.1) 0%, transparent 50%);
            pointer-events: none;
            animation: pulseBackground 4s ease-in-out infinite alternate;
        }

        @keyframes pulseBackground {
            0% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }

        #gameCanvas {
            border: 2px solid #00ffff;
            border-radius: 20px;
            box-shadow:
                0 0 30px rgba(0, 255, 255, 0.5),
                inset 0 0 20px rgba(0, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.3);
        }

        .game-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            position: relative;
            z-index: 1;
        }

        .ui-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(145deg, rgba(0, 20, 40, 0.9), rgba(0, 30, 60, 0.8));
            border: 1px solid rgba(0, 255, 255, 0.3);
            padding: 20px;
            border-radius: 15px;
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.3),
                0 0 20px rgba(0, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            font-family: 'Orbitron', monospace;
        }

        .ui-panel h3 {
            margin: 0 0 15px 0;
            color: #00ffff;
            font-size: 18px;
            text-align: center;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
            font-weight: 700;
        }

        .ui-panel div {
            color: #a0f0ff;
            margin-bottom: 8px;
            font-size: 14px;
            text-shadow: 0 0 5px rgba(160, 240, 255, 0.5);
        }

        .instructions-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: linear-gradient(145deg, rgba(0, 20, 40, 0.95), rgba(0, 30, 60, 0.9));
            border: 1px solid rgba(0, 255, 255, 0.3);
            padding: 25px;
            border-radius: 15px;
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.3),
                0 0 20px rgba(0, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            width: 220px;
            font-size: 14px;
            line-height: 1.6;
            font-family: 'Exo 2', sans-serif;
        }

        .instructions-panel h3 {
            margin: 0 0 20px 0;
            color: #00ffff;
            font-size: 18px;
            text-align: center;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            text-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
        }

        .instructions-panel .control-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }

        .instructions-panel .control-item:hover {
            transform: translateX(5px);
        }

        .instructions-panel .key {
            background: linear-gradient(145deg, #001122, #002244);
            color: #00ffff;
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid rgba(0, 255, 255, 0.4);
            font-family: 'Orbitron', monospace;
            margin-right: 12px;
            min-width: 25px;
            text-align: center;
            font-weight: 700;
            box-shadow:
                0 2px 8px rgba(0, 0, 0, 0.3),
                0 0 10px rgba(0, 255, 255, 0.2);
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.8);
        }

        .instructions-panel .desc {
            color: #a0f0ff;
            font-weight: 300;
            text-shadow: 0 0 3px rgba(160, 240, 255, 0.3);
        }

        .game-rules {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(0, 255, 255, 0.2);
            color: #80d0ff;
            font-size: 12px;
            line-height: 1.5;
        }

        .game-rules .rule-item {
            margin-bottom: 6px;
            padding-left: 8px;
            position: relative;
        }

        .game-rules .rule-item::before {
            content: '‚ñ∂';
            position: absolute;
            left: 0;
            color: #00ffff;
            font-size: 10px;
        }

        .win-condition {
            background: linear-gradient(90deg, rgba(255, 215, 0, 0.1), rgba(255, 215, 0, 0.05));
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin-top: 15px;
            text-align: center;
        }

        .win-condition .title {
            color: #ffd700;
            font-weight: 700;
            font-size: 13px;
            margin-bottom: 5px;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.8);
        }

        .win-condition .desc {
            color: #ffed4e;
            font-size: 11px;
            text-shadow: 0 0 5px rgba(255, 237, 78, 0.5);
        }

        /* Victory Modal Styles */
        .victory-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: modalFadeIn 0.5s ease;
        }

        .victory-modal.show {
            display: flex;
        }

        @keyframes modalFadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .victory-content {
            background: linear-gradient(145deg, rgba(0, 20, 40, 0.95), rgba(0, 30, 60, 0.9));
            border: 2px solid #00ffff;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow:
                0 0 50px rgba(0, 255, 255, 0.5),
                inset 0 0 30px rgba(0, 255, 255, 0.1);
            animation: victoryPulse 2s ease-in-out infinite alternate;
            min-width: 400px;
        }

        @keyframes victoryPulse {
            0% {
                box-shadow: 0 0 50px rgba(0, 255, 255, 0.3), inset 0 0 30px rgba(0, 255, 255, 0.1);
            }

            100% {
                box-shadow: 0 0 80px rgba(0, 255, 255, 0.7), inset 0 0 50px rgba(0, 255, 255, 0.2);
            }
        }

        .victory-title {
            font-family: 'Orbitron', monospace;
            font-size: 32px;
            font-weight: 900;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            margin-bottom: 20px;
            animation: titleGlow 1s ease-in-out infinite alternate;
        }

        @keyframes titleGlow {
            0% {
                text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            }

            100% {
                text-shadow: 0 0 30px rgba(255, 215, 0, 1), 0 0 40px rgba(255, 215, 0, 0.7);
            }
        }

        .victory-subtitle {
            font-family: 'Exo 2', sans-serif;
            font-size: 18px;
            color: #00ffff;
            margin-bottom: 30px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .ready-status {
            margin: 20px 0;
            font-family: 'Exo 2', sans-serif;
        }

        .player-ready {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 10px 15px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
        }

        .ready-button {
            background: linear-gradient(145deg, #00aa66, #008844);
            border: 2px solid #00ffaa;
            color: white;
            padding: 12px 25px;
            border-radius: 8px;
            font-family: 'Orbitron', monospace;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 255, 170, 0.3);
            transition: all 0.3s ease;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }

        .ready-button:hover {
            background: linear-gradient(145deg, #00cc77, #00aa55);
            box-shadow: 0 6px 20px rgba(0, 255, 170, 0.5);
            transform: translateY(-2px);
        }

        .ready-button:disabled {
            background: linear-gradient(145deg, #666, #444);
            border-color: #888;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        .ready-indicator {
            color: #00ffaa;
            font-weight: bold;
            text-shadow: 0 0 8px rgba(0, 255, 170, 0.8);
        }

        .not-ready {
            color: #ffaa00;
        }
    </style>
</head>

<body>
    <div class="game-container">
        <div class="instructions-panel">
            <h3>‚ó§ ÊìçÊéßÊåáÂçó ‚ó•</h3>
            <div class="control-item">
                <span class="key">W</span>
                <span class="desc">Âêë‰∏äÊé®Ëøõ</span>
            </div>
            <div class="control-item">
                <span class="key">S</span>
                <span class="desc">Âêë‰∏ãÈôçËêΩ</span>
            </div>
            <div class="control-item">
                <span class="key">A</span>
                <span class="desc">Â∑¶‰æßÈó™ÈÅø</span>
            </div>
            <div class="control-item">
                <span class="key">D</span>
                <span class="desc">Âè≥‰æßÁ™ÅËøõ</span>
            </div>
            <div class="control-item">
                <span class="key">Á©∫Ê†º</span>
                <span class="desc">ËÉΩÈáèÂ∞ÑÂáª</span>
            </div>
            <div class="control-item">
                <span class="key">Â∑¶ÈîÆ</span>
                <span class="desc">Èº†Ê†áÂ∞ÑÂáª</span>
            </div>

            <div class="game-rules">
                <div class="rule-item">ÁßªÂä®Èº†Ê†áÁûÑÂáÜÁõÆÊ†á</div>
                <div class="rule-item">ÂëΩ‰∏≠Êïå‰∫∫Ëé∑ÂæóÂàÜÊï∞</div>
                <div class="rule-item">ÈöúÁ¢çÁâ©ÈòªÊå°ÊîªÂáª</div>
                <div class="rule-item">Ë¢´Âáª‰∏≠‰ºöÂêéÈÄÄÂπ∂Â§±Ë°Ä</div>
            </div>

            <div class="win-condition">
                <div class="title">üèÜ ËÉúÂà©Êù°‰ª∂</div>
                <div class="desc">ÁéáÂÖàËé∑Âæó 6 ÂàÜËÄÖËé∑ËÉú</div>
            </div>
        </div>

        <div class="ui-panel">
            <h3>‚ó§ CYBER ARENA ‚ó•</h3>
            <div id="player1Score">üî¥ Áé©ÂÆ∂1: 0ÂàÜ</div>
            <div id="player2Score">üîµ Áé©ÂÆ∂2: 0ÂàÜ</div>
            <div id="playerCount">üåê Âú®Á∫ø: 1</div>
            <div id="gameStatus">‚è≥ Á≠âÂæÖÂØπÊâãÂä†ÂÖ•...</div>
        </div>

        <canvas id="gameCanvas" width="800" height="600"></canvas>

        <!-- Victory Modal -->
        <div id="victoryModal" class="victory-modal">
            <div class="victory-content">
                <div class="victory-title" id="victoryTitle">üèÜ VICTORY! üèÜ</div>
                <div class="victory-subtitle" id="victorySubtitle">ÊÅ≠ÂñúÁé©ÂÆ∂1Ëé∑ËÉúÔºÅ</div>
            </div>
        </div>
    </div>

    <script>
        // Game constants
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const CANDY_SIZE = 25;
        const PLAYER_SPEED = 5;
        const BULLET_SPEED = 8;
        const BULLET_SIZE = 8;
        const BOUNCE_DAMPING = 0.8;
        const OBSTACLE_COUNT = 8;

        // MultiSynq Game Model
        class CandyBattleGame extends Multisynq.Model {
            init() {
                this.players = new Map();
                this.bullets = new Set();
                this.obstacles = this.generateObstacles();
                this.gameStarted = false;
                this.scores = { player1: 0, player2: 0 };
                this.gameEnded = false;
                this.playersReady = new Set();

                this.subscribe(this.sessionId, "view-join", this.onPlayerJoin);
                this.subscribe(this.sessionId, "view-exit", this.onPlayerExit);
                this.subscribe(this.sessionId, "player-ready", this.onPlayerReady);

                this.gameLoop();
            }

            generateObstacles() {
                const obstacles = [];
                for (let i = 0; i < OBSTACLE_COUNT; i++) {
                    let x, y;
                    let validPosition = false;
                    let attempts = 0;

                    // Â∞ùËØïÊâæÂà∞‰∏ç‰∏éÁé©ÂÆ∂Ëµ∑Âßã‰ΩçÁΩÆÂÜ≤Á™ÅÁöÑÈöúÁ¢çÁâ©‰ΩçÁΩÆ
                    while (!validPosition && attempts < 50) {
                        x = Math.random() * (CANVAS_WIDTH - 100) + 50;
                        y = Math.random() * (CANVAS_HEIGHT - 100) + 50;

                        // Á°Æ‰øùÈöúÁ¢çÁâ©‰∏çÂú®Áé©ÂÆ∂Ëµ∑Âßã‰ΩçÁΩÆÈôÑËøë
                        const leftSpawn = { x: 100, y: CANVAS_HEIGHT / 2 };
                        const rightSpawn = { x: CANVAS_WIDTH - 100, y: CANVAS_HEIGHT / 2 };

                        const distToLeft = Math.sqrt((x - leftSpawn.x) ** 2 + (y - leftSpawn.y) ** 2);
                        const distToRight = Math.sqrt((x - rightSpawn.x) ** 2 + (y - rightSpawn.y) ** 2);

                        if (distToLeft > 80 && distToRight > 80) {
                            validPosition = true;
                        }
                        attempts++;
                    }

                    obstacles.push({
                        x: x,
                        y: y,
                        width: 40 + Math.random() * 40,
                        height: 40 + Math.random() * 40,
                        type: Math.random() > 0.5 ? 'rect' : 'circle'
                    });
                }
                return obstacles;
            }

            onPlayerJoin(viewInfo) {
                const { viewId } = viewInfo;
                const playerNumber = this.players.size + 1;

                if (playerNumber <= 2) {
                    const player = {
                        id: viewId,
                        number: playerNumber,
                        x: playerNumber === 1 ? 100 : CANVAS_WIDTH - 100,
                        y: CANVAS_HEIGHT / 2,
                        vx: 0,
                        vy: 0,
                        color: playerNumber === 1 ? '#ff6b6b' : '#4ecdc4',
                        health: 3,
                        lastShot: 0
                    };

                    this.players.set(viewId, player);
                    this.subscribe(viewId, "move", this.onPlayerMove);
                    this.subscribe(viewId, "shoot", this.onPlayerShoot);

                    if (this.players.size === 2) {
                        this.gameStarted = true;
                        this.publish(this.sessionId, "game-start", {});
                    }

                    this.publish(this.sessionId, "player-joined", { player, totalPlayers: this.players.size });
                }
            }

            onPlayerExit(viewInfo) {
                const { viewId } = viewInfo;
                this.players.delete(viewId);
                this.unsubscribe(viewId, "move");
                this.unsubscribe(viewId, "shoot");

                if (this.players.size < 2) {
                    this.gameStarted = false;
                }

                this.publish(this.sessionId, "player-left", { totalPlayers: this.players.size });
            }

            onPlayerMove(data) {
                const { direction, pressing } = data;
                const player = this.players.get(this.activeSubscription.scope);
                if (!player || !this.gameStarted) return;

                switch (direction) {
                    case 'up':
                        player.vy = pressing ? -PLAYER_SPEED : 0;
                        break;
                    case 'down':
                        player.vy = pressing ? PLAYER_SPEED : 0;
                        break;
                    case 'left':
                        player.vx = pressing ? -PLAYER_SPEED : 0;
                        break;
                    case 'right':
                        player.vx = pressing ? PLAYER_SPEED : 0;
                        break;
                }
            }

            onPlayerShoot(data) {
                const { mouseX, mouseY } = data;
                const player = this.players.get(this.activeSubscription.scope);
                if (!player || !this.gameStarted) return;

                const now = this.now();
                if (now - player.lastShot < 300) return; // Â∞ÑÂáªÂÜ∑Âç¥Êó∂Èó¥

                player.lastShot = now;

                // ËÆ°ÁÆóÈº†Ê†áÊñπÂêë
                const dx = mouseX - player.x;
                const dy = mouseY - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance === 0) return; // ÈÅøÂÖçÈô§Èõ∂ÈîôËØØ

                // Ê†áÂáÜÂåñÊñπÂêëÂêëÈáè
                const normalizedDx = (dx / distance) * BULLET_SPEED;
                const normalizedDy = (dy / distance) * BULLET_SPEED;

                const bullet = {
                    id: `${player.id}_${now}`,
                    x: player.x + (normalizedDx * 2),
                    y: player.y + (normalizedDy * 2),
                    vx: normalizedDx,
                    vy: normalizedDy,
                    owner: player.id,
                    bounces: 0
                };

                this.bullets.add(bullet);
                this.publish(this.sessionId, "bullet-fired", bullet);
            }

            gameLoop() {
                if (this.gameStarted) {
                    this.updatePlayers();
                    this.updateBullets();
                    this.checkCollisions();
                }

                this.future(16).gameLoop(); // ~60 FPS
            }

            updatePlayers() {
                for (const player of this.players.values()) {
                    const newX = player.x + player.vx;
                    const newY = player.y + player.vy;

                    // Ê£ÄÊü•‰∏éÈöúÁ¢çÁâ©ÁöÑÁ¢∞Êíû
                    let canMoveX = true;
                    let canMoveY = true;

                    for (const obstacle of this.obstacles) {
                        if (this.checkPlayerObstacleCollision(newX, player.y, obstacle)) {
                            canMoveX = false;
                        }
                        if (this.checkPlayerObstacleCollision(player.x, newY, obstacle)) {
                            canMoveY = false;
                        }
                    }

                    // Êõ¥Êñ∞‰ΩçÁΩÆ
                    if (canMoveX) player.x = newX;
                    if (canMoveY) player.y = newY;

                    // ËæπÁïåÊ£ÄÊµãÂíåÂºπÊÄßÁ¢∞Êíû
                    if (player.x <= CANDY_SIZE / 2) {
                        player.x = CANDY_SIZE / 2;
                        player.vx *= -BOUNCE_DAMPING;
                    }
                    if (player.x >= CANVAS_WIDTH - CANDY_SIZE / 2) {
                        player.x = CANVAS_WIDTH - CANDY_SIZE / 2;
                        player.vx *= -BOUNCE_DAMPING;
                    }
                    if (player.y <= CANDY_SIZE / 2) {
                        player.y = CANDY_SIZE / 2;
                        player.vy *= -BOUNCE_DAMPING;
                    }
                    if (player.y >= CANVAS_HEIGHT - CANDY_SIZE / 2) {
                        player.y = CANVAS_HEIGHT - CANDY_SIZE / 2;
                        player.vy *= -BOUNCE_DAMPING;
                    }

                    // Ê∑ªÂä†Êë©Êì¶Âäõ
                    player.vx *= 0.95;
                    player.vy *= 0.95;
                }
            }

            checkPlayerObstacleCollision(playerX, playerY, obstacle) {
                if (obstacle.type === 'circle') {
                    const radius = obstacle.width / 2;
                    const dx = playerX - obstacle.x;
                    const dy = playerY - obstacle.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return distance < (radius + CANDY_SIZE / 2);
                } else {
                    // Áü©ÂΩ¢Á¢∞ÊíûÊ£ÄÊµã
                    return playerX - CANDY_SIZE / 2 < obstacle.x + obstacle.width / 2 &&
                        playerX + CANDY_SIZE / 2 > obstacle.x - obstacle.width / 2 &&
                        playerY - CANDY_SIZE / 2 < obstacle.y + obstacle.height / 2 &&
                        playerY + CANDY_SIZE / 2 > obstacle.y - obstacle.height / 2;
                }
            }

            updateBullets() {
                const bulletsToRemove = [];

                for (const bullet of this.bullets) {
                    const newX = bullet.x + bullet.vx;
                    const newY = bullet.y + bullet.vy;

                    // Ê£ÄÊü•‰∏éÈöúÁ¢çÁâ©ÁöÑÁ¢∞Êíû
                    let hitObstacle = false;
                    for (const obstacle of this.obstacles) {
                        if (this.checkBulletObstacleCollision(newX, newY, obstacle)) {
                            hitObstacle = true;
                            break;
                        }
                    }

                    if (hitObstacle) {
                        bulletsToRemove.push(bullet);
                        continue;
                    }

                    bullet.x = newX;
                    bullet.y = newY;

                    // Â≠êÂºπËæπÁïåÂèçÂºπ
                    let bounced = false;
                    if (bullet.x <= BULLET_SIZE / 2 || bullet.x >= CANVAS_WIDTH - BULLET_SIZE / 2) {
                        bullet.vx *= -BOUNCE_DAMPING;
                        bullet.x = Math.max(BULLET_SIZE / 2, Math.min(CANVAS_WIDTH - BULLET_SIZE / 2, bullet.x));
                        bounced = true;
                    }
                    if (bullet.y <= BULLET_SIZE / 2 || bullet.y >= CANVAS_HEIGHT - BULLET_SIZE / 2) {
                        bullet.vy *= -BOUNCE_DAMPING;
                        bullet.y = Math.max(BULLET_SIZE / 2, Math.min(CANVAS_HEIGHT - BULLET_SIZE / 2, bullet.y));
                        bounced = true;
                    }

                    if (bounced) {
                        bullet.bounces++;
                        if (bullet.bounces > 5) {
                            bulletsToRemove.push(bullet);
                        }
                    }
                }

                // ÁßªÈô§Ë¢´ÈòªÊå°ÊàñË∂ÖÂá∫ËæπÁïåÁöÑÂ≠êÂºπ
                for (const bullet of bulletsToRemove) {
                    this.bullets.delete(bullet);
                }
            }

            checkBulletObstacleCollision(bulletX, bulletY, obstacle) {
                if (obstacle.type === 'circle') {
                    const radius = obstacle.width / 2;
                    const dx = bulletX - obstacle.x;
                    const dy = bulletY - obstacle.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return distance < (radius + BULLET_SIZE / 2);
                } else {
                    // Áü©ÂΩ¢Á¢∞ÊíûÊ£ÄÊµã
                    return bulletX - BULLET_SIZE / 2 < obstacle.x + obstacle.width / 2 &&
                        bulletX + BULLET_SIZE / 2 > obstacle.x - obstacle.width / 2 &&
                        bulletY - BULLET_SIZE / 2 < obstacle.y + obstacle.height / 2 &&
                        bulletY + BULLET_SIZE / 2 > obstacle.y - obstacle.height / 2;
                }
            }

            checkCollisions() {
                for (const bullet of this.bullets) {
                    for (const player of this.players.values()) {
                        if (bullet.owner === player.id) continue;

                        const dx = bullet.x - player.x;
                        const dy = bullet.y - player.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < (BULLET_SIZE + CANDY_SIZE) / 2) {
                            // ÂëΩ‰∏≠ÔºÅ
                            player.health--;
                            this.bullets.delete(bullet);

                            // ÂáªÈÄÄÊïàÊûú
                            const force = 10;
                            player.vx += (dx / distance) * force;
                            player.vy += (dy / distance) * force;

                            // Êõ¥Êñ∞ÂàÜÊï∞
                            const shooter = Array.from(this.players.values()).find(p => p.id === bullet.owner);
                            if (shooter) {
                                if (shooter.number === 1) {
                                    this.scores.player1++;
                                } else {
                                    this.scores.player2++;
                                }
                            }

                            this.publish(this.sessionId, "player-hit", {
                                victim: player.id,
                                shooter: bullet.owner,
                                scores: this.scores
                            });

                            // Ê£ÄÊü•Ê∏∏ÊàèÁªìÊùüÊù°‰ª∂ÔºöÂÖàËææÂà∞6ÂàÜËé∑ËÉú
                            if (this.scores.player1 >= 6 || this.scores.player2 >= 6) {
                                const winner = this.scores.player1 >= 6 ? 1 : 2;
                                this.gameEnded = true;
                                this.gameStarted = false;
                                this.playersReady.clear();
                                this.publish(this.sessionId, "game-over", {
                                    winner: winner,
                                    scores: this.scores
                                });
                            } else if (player.health <= 0) {
                                // Ë°ÄÈáè‰∏∫0Êó∂ÈáçÁΩÆ‰ΩçÁΩÆ‰ΩÜ‰∏çÁªìÊùüÊ∏∏Êàè
                                player.health = 3;
                                player.x = player.number === 1 ? 100 : CANVAS_WIDTH - 100;
                                player.y = CANVAS_HEIGHT / 2;
                                player.vx = 0;
                                player.vy = 0;
                            }

                            break;
                        }
                    }
                }
            }

            onPlayerReady(data) {
                const playerId = this.activeSubscription.scope;
                this.playersReady.add(playerId);

                this.publish(this.sessionId, "player-ready-status", {
                    playerId: playerId,
                    readyPlayers: Array.from(this.playersReady),
                    totalPlayers: this.players.size
                });

                // Â¶ÇÊûúÊâÄÊúâÁé©ÂÆ∂ÈÉΩÂáÜÂ§áÂ•Ω‰∫ÜÔºåÂºÄÂßãÊñ∞Ê∏∏Êàè
                if (this.playersReady.size === this.players.size && this.gameEnded) {
                    this.resetGame();
                }
            }

            resetGame() {
                // ÈáçÁΩÆÊ∏∏ÊàèÁä∂ÊÄÅ
                this.bullets.clear();
                this.scores = { player1: 0, player2: 0 };
                this.gameEnded = false;
                this.gameStarted = this.players.size === 2;
                this.playersReady.clear();

                // ÈáçÊñ∞ÁîüÊàêÈöúÁ¢çÁâ©
                this.obstacles = this.generateObstacles();
                for (const player of this.players.values()) {
                    player.health = 3;
                    player.x = player.number === 1 ? 100 : CANVAS_WIDTH - 100;
                    player.y = CANVAS_HEIGHT / 2;
                    player.vx = 0;
                    player.vy = 0;
                }
                // ÈÄöÁü•ËßÜÂõæÈöúÁ¢çÁâ©Â∑≤Êõ¥Êñ∞
                this.publish(this.sessionId, "obstacles-updated", { obstacles: this.obstacles });
                this.publish(this.sessionId, "game-reset", { scores: this.scores });
            }
        }
        CandyBattleGame.register("CandyBattleGame");

        // MultiSynq View
        class CandyBattleView extends Multisynq.View {
            constructor(model) {
                super(model);
                this.model = model;
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');

                this.keys = {};
                this.mouseX = 0;
                this.mouseY = 0;
                this.setupControls();
                this.setupEventListeners();
                this.setupAudio();

                // UI elements
                this.player1ScoreEl = document.getElementById('player1Score');
                this.player2ScoreEl = document.getElementById('player2Score');
                this.playerCountEl = document.getElementById('playerCount');
                this.gameStatusEl = document.getElementById('gameStatus');

                this.subscribe(this.sessionId, "player-joined", (...args) => this.onPlayerJoined(...args));
                this.subscribe(this.sessionId, "player-left", (...args) => this.onPlayerLeft(...args));
                this.subscribe(this.sessionId, "game-start", (...args) => this.onGameStart(...args));
                this.subscribe(this.sessionId, "player-hit", (...args) => this.onPlayerHit(...args));
                this.subscribe(this.sessionId, "game-over", (...args) => this.onGameOver(...args));
                this.subscribe(this.sessionId, "bullet-fired", (...args) => this.onBulletFired(...args));
                this.subscribe(this.sessionId, "obstacles-updated", (...args) => this.onObstaclesUpdated(...args));
                this.subscribe(this.sessionId, "game-reset", (...args) => this.onGameReset(...args));
                this.subscribe(this.sessionId, "player-ready-status", (...args) => this.onPlayerReadyStatus(...args));

                // Ëé∑ÂèñmodalÂÖÉÁ¥†
                this.victoryModal = document.getElementById('victoryModal');
                this.victoryTitle = document.getElementById('victoryTitle');
                this.victorySubtitle = document.getElementById('victorySubtitle');

                this.render();
            }

            setupAudio() {
                // ËÆæÁΩÆËÉåÊôØÈü≥‰πê
                this.bgMusic = new Audio('./bgm.MP3');
                this.bgMusic.loop = true;
                this.bgMusic.volume = 0.3;

                // ÂàõÂª∫Èü≥Êïà
                this.shootSound = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+Dxu2YgBSuO4vfUfzEIJnfL8eMcUhkUe8H2wHkqASN');
                this.hitSound = new Audio('data:audio/wav;base64,UklGRv4CAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YdoCAAC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4QEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQ');

                this.shootSound.volume = 0.2;
                this.hitSound.volume = 0.3;

                // Áî®Êà∑‰∫§‰∫íÂêéÊí≠ÊîæÈü≥‰πêÔºàÊµèËßàÂô®ÊîøÁ≠ñË¶ÅÊ±ÇÔºâ
                const playMusic = () => {
                    this.bgMusic.play().catch(e => console.log('Audio play failed:', e));
                    document.removeEventListener('click', playMusic);
                    document.removeEventListener('keydown', playMusic);
                };
                document.addEventListener('click', playMusic);
                document.addEventListener('keydown', playMusic);
            }

            setupControls() {
                // Èº†Ê†á‰ΩçÁΩÆË∑üË∏™
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouseX = (e.clientX - rect.left) * (CANVAS_WIDTH / rect.width);
                    this.mouseY = (e.clientY - rect.top) * (CANVAS_HEIGHT / rect.height);
                });

                // Èº†Ê†áÁÇπÂáªÂ∞ÑÂáª
                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = (e.clientX - rect.left) * (CANVAS_WIDTH / rect.width);
                    const mouseY = (e.clientY - rect.top) * (CANVAS_HEIGHT / rect.height);
                    this.publish(this.viewId, "shoot", { mouseX, mouseY });
                });

                // ÈîÆÁõòÊéßÂà∂
                document.addEventListener('keydown', (e) => {
                    if (!this.keys[e.code]) {
                        this.keys[e.code] = true;
                        this.handleKeyChange(e.code, true);
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                    this.handleKeyChange(e.code, false);
                });

            }

            handleKeyChange(code, pressing) {
                const keyMap = {
                    'KeyW': 'up',
                    'KeyS': 'down',
                    'KeyA': 'left',
                    'KeyD': 'right'
                };

                const direction = keyMap[code];
                if (direction) {
                    this.publish(this.viewId, "move", { direction, pressing });
                }

                if (code === 'Space' && pressing) {
                    this.publish(this.viewId, "shoot", { mouseX: this.mouseX, mouseY: this.mouseY });
                }
            }

            setupEventListeners() {
                // Èò≤Ê≠¢ÈªòËÆ§ÁöÑÈîÆÁõòË°å‰∏∫
                document.addEventListener('keydown', (e) => {
                    if (['KeyW', 'KeyA', 'KeyS', 'KeyD', 'Space'].includes(e.code)) {
                        e.preventDefault();
                    }
                });
            }

            onPlayerJoined(data) {
                const { totalPlayers } = data;
                this.playerCountEl.textContent = `üåê Âú®Á∫ø: ${totalPlayers}`;
                if (totalPlayers === 2) {
                    this.gameStatusEl.textContent = "‚ö° ÊàòÊñóÂºÄÂßãÔºÅ";
                }
            }

            onPlayerLeft(data) {
                const { totalPlayers } = data;
                this.playerCountEl.textContent = `üåê Âú®Á∫ø: ${totalPlayers}`;
                this.gameStatusEl.textContent = "‚è≥ Á≠âÂæÖÂØπÊâãÂä†ÂÖ•...";
            }

            onGameStart() {
                this.gameStatusEl.textContent = "üî• ÊøÄÊàòËøõË°å‰∏≠";
            }

            onPlayerHit(data) {
                const { scores } = data;
                this.player1ScoreEl.textContent = `üî¥ Áé©ÂÆ∂1: ${scores.player1}ÂàÜ`;
                this.player2ScoreEl.textContent = `üîµ Áé©ÂÆ∂2: ${scores.player2}ÂàÜ`;

                // Ê∑ªÂä†Âáª‰∏≠ÁâπÊïà
                this.showHitEffect();
            }

            onGameOver(data) {
                const { winner } = data;
                this.gameStatusEl.textContent = `üèÜ Áé©ÂÆ∂${winner}Ëé∑ËÉúÔºÅ`;

                // ÊòæÁ§∫ËÉúÂà©Ê®°ÊÄÅÊ°Ü
                this.victoryTitle.textContent = `üèÜ VICTORY! üèÜ`;
                this.victorySubtitle.textContent = `ÊÅ≠ÂñúÁé©ÂÆ∂${winner}Ëé∑ËÉúÔºÅ`;

                // ÊòæÁ§∫Ê®°ÊÄÅÊ°Ü
                this.victoryModal.classList.add('show');
            }

            onGameReset(data) {
                const { scores } = data;
                this.player1ScoreEl.textContent = `üî¥ Áé©ÂÆ∂1: ${scores.player1}ÂàÜ`;
                this.player2ScoreEl.textContent = `üîµ Áé©ÂÆ∂2: ${scores.player2}ÂàÜ`;
            }

            onBulletFired(bullet) {
                // ÂèØ‰ª•Ê∑ªÂä†Â∞ÑÂáªÈü≥ÊïàÊàñÁâπÊïà
                this.showShootEffect(bullet);
            }

            onObstaclesUpdated(data) {
                // ÈöúÁ¢çÁâ©Â∑≤Âú®Ê®°Âûã‰∏≠Êõ¥Êñ∞ÔºåËßÜÂõæ‰ºöÂú®‰∏ã‰∏ÄÂ∏ßÊ∏≤ÊüìÊó∂Ëá™Âä®‰ΩøÁî®Êñ∞ÁöÑÈöúÁ¢çÁâ©
                console.log('ÈöúÁ¢çÁâ©Â∑≤ÈáçÊñ∞ÁîüÊàê');
            }

            showHitEffect() {
                // ÁÆÄÂçïÁöÑÂ±èÂπïÈúáÂä®ÊïàÊûú
                this.canvas.style.transform = 'translate(2px, 2px)';
                setTimeout(() => {
                    this.canvas.style.transform = 'translate(-2px, -2px)';
                    setTimeout(() => {
                        this.canvas.style.transform = 'translate(0, 0)';
                    }, 50);
                }, 50);
            }

            showShootEffect(bullet) {
                // Âú®Â∞ÑÂáª‰ΩçÁΩÆÊ∑ªÂä†Èó™ÂÖâÊïàÊûú
                this.ctx.save();
                this.ctx.globalAlpha = 0.7;
                this.ctx.fillStyle = '#ffff00';
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, 15, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
            }

            update() {
                this.render();
            }

            render() {
                // Ê∏ÖÁ©∫ÁîªÂ∏É
                this.ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // ÁªòÂà∂ËÉåÊôØÁΩëÊ†º
                this.drawBackground();

                // ÁªòÂà∂ÈöúÁ¢çÁâ©
                for (const obstacle of this.model.obstacles) {
                    this.drawObstacle(obstacle);
                }

                // ÁªòÂà∂Áé©ÂÆ∂
                for (const player of this.model.players.values()) {
                    this.drawPlayer(player);
                }

                // ÁªòÂà∂Â≠êÂºπ
                for (const bullet of this.model.bullets) {
                    this.drawBullet(bullet);
                }

                // ÁªòÂà∂Èº†Ê†áÊåáÈíàÂíåÂ∞ÑÂáªÁ∫ø
                this.drawAimingLine();
            }

            drawBackground() {
                // ÁªòÂà∂ÁßëÂπªÁΩëÊ†ºËÉåÊôØ
                this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.15)';
                this.ctx.lineWidth = 1;

                // ‰∏ªÁΩëÊ†º
                for (let x = 0; x < CANVAS_WIDTH; x += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, CANVAS_HEIGHT);
                    this.ctx.stroke();
                }

                for (let y = 0; y < CANVAS_HEIGHT; y += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(CANVAS_WIDTH, y);
                    this.ctx.stroke();
                }

                // ÁªÜÁΩëÊ†º
                this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.05)';
                this.ctx.lineWidth = 0.5;
                for (let x = 0; x < CANVAS_WIDTH; x += 25) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, CANVAS_HEIGHT);
                    this.ctx.stroke();
                }

                for (let y = 0; y < CANVAS_HEIGHT; y += 25) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(CANVAS_WIDTH, y);
                    this.ctx.stroke();
                }

                // Êâ´ÊèèÁ∫øÊïàÊûú
                const time = Date.now() * 0.001;
                this.ctx.strokeStyle = `rgba(0, 255, 255, ${0.3 + Math.sin(time * 2) * 0.2})`;
                this.ctx.lineWidth = 2;
                const scanY = (time * 100) % CANVAS_HEIGHT;
                this.ctx.beginPath();
                this.ctx.moveTo(0, scanY);
                this.ctx.lineTo(CANVAS_WIDTH, scanY);
                this.ctx.stroke();
            }

            drawPlayer(player) {
                this.ctx.save();

                const time = Date.now() * 0.003;
                const pulseFactor = 1 + Math.sin(time + player.number) * 0.1;

                // ÁªòÂà∂Â§ñÈÉ®ËÉΩÈáèÂú∫
                const outerGlow = this.ctx.createRadialGradient(
                    player.x, player.y, 0,
                    player.x, player.y, CANDY_SIZE * 1.2
                );
                outerGlow.addColorStop(0, `rgba(${player.number === 1 ? '255, 50, 50' : '50, 200, 255'}, 0.3)`);
                outerGlow.addColorStop(1, 'transparent');

                this.ctx.fillStyle = outerGlow;
                this.ctx.beginPath();
                this.ctx.arc(player.x, player.y, CANDY_SIZE * 0.8 * pulseFactor, 0, Math.PI * 2);
                this.ctx.fill();

                // ÁªòÂà∂‰∏ª‰ΩìÂÖ≠ËæπÂΩ¢
                this.ctx.translate(player.x, player.y);
                this.ctx.rotate(time * 0.5);

                // Â§ñÂ£≥
                const shellGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, CANDY_SIZE / 2);
                if (player.number === 1) {
                    shellGradient.addColorStop(0, '#ff6b6b');
                    shellGradient.addColorStop(0.7, '#ff3838');
                    shellGradient.addColorStop(1, '#cc1414');
                } else {
                    shellGradient.addColorStop(0, '#4ecdc4');
                    shellGradient.addColorStop(0.7, '#26a69a');
                    shellGradient.addColorStop(1, '#1a7874');
                }

                this.ctx.fillStyle = shellGradient;
                this.ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i * Math.PI) / 3;
                    const x = Math.cos(angle) * (CANDY_SIZE / 2 - 2);
                    const y = Math.sin(angle) * (CANDY_SIZE / 2 - 2);
                    if (i === 0) this.ctx.moveTo(x, y);
                    else this.ctx.lineTo(x, y);
                }
                this.ctx.closePath();
                this.ctx.fill();

                // ÂÜÖÈÉ®Ê†∏ÂøÉ
                const coreGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, CANDY_SIZE / 4);
                coreGradient.addColorStop(0, '#ffffff');
                coreGradient.addColorStop(0.5, player.number === 1 ? '#ffaaaa' : '#aaffff');
                coreGradient.addColorStop(1, player.number === 1 ? '#ff6666' : '#66dddd');

                this.ctx.fillStyle = coreGradient;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, CANDY_SIZE / 4, 0, Math.PI * 2);
                this.ctx.fill();

                // ËÉΩÈáèÁ∫øÊù°
                this.ctx.strokeStyle = player.number === 1 ? '#ff0044' : '#0088ff';
                this.ctx.lineWidth = 2;
                this.ctx.shadowColor = player.number === 1 ? '#ff0044' : '#0088ff';
                this.ctx.shadowBlur = 8;

                for (let i = 0; i < 3; i++) {
                    const angle = (i * Math.PI * 2) / 3 + time;
                    this.ctx.beginPath();
                    this.ctx.moveTo(Math.cos(angle) * 8, Math.sin(angle) * 8);
                    this.ctx.lineTo(Math.cos(angle) * (CANDY_SIZE / 2 - 4), Math.sin(angle) * (CANDY_SIZE / 2 - 4));
                    this.ctx.stroke();
                }

                this.ctx.shadowBlur = 0;
                this.ctx.restore();

                // ÁªòÂà∂Áé©ÂÆ∂ÁºñÂè∑
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = 'bold 12px Orbitron';
                this.ctx.textAlign = 'center';
                this.ctx.strokeStyle = '#000000';
                this.ctx.lineWidth = 2;
                this.ctx.strokeText(player.number.toString(), player.x, player.y + 4);
                this.ctx.fillText(player.number.toString(), player.x, player.y + 4);

                // ÁªòÂà∂Ë°ÄÈáè
                this.drawHealthBar(player);
            }

            drawHealthBar(player) {
                const barWidth = 45;
                const barHeight = 8;
                const x = player.x - barWidth / 2;
                const y = player.y - CANDY_SIZE / 2 - 20;

                // Â§ñÂèëÂÖâÊïàÊûú
                this.ctx.shadowColor = '#00ffff';
                this.ctx.shadowBlur = 4;

                // ËÉåÊôØ
                this.ctx.fillStyle = 'rgba(0, 20, 40, 0.8)';
                this.ctx.fillRect(x - 1, y - 1, barWidth + 2, barHeight + 2);

                // Ë°ÄÈáèÊù°
                const healthPercent = player.health / 3;
                const healthGradient = this.ctx.createLinearGradient(x, y, x + barWidth, y);

                if (healthPercent > 0.6) {
                    healthGradient.addColorStop(0, '#00ff88');
                    healthGradient.addColorStop(1, '#00cc66');
                } else if (healthPercent > 0.3) {
                    healthGradient.addColorStop(0, '#ffaa00');
                    healthGradient.addColorStop(1, '#ff8800');
                } else {
                    healthGradient.addColorStop(0, '#ff4444');
                    healthGradient.addColorStop(1, '#cc0000');
                }

                this.ctx.fillStyle = healthGradient;
                this.ctx.fillRect(x, y, barWidth * healthPercent, barHeight);

                // ËæπÊ°Ü
                this.ctx.strokeStyle = '#00ffff';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(x, y, barWidth, barHeight);

                // ÂÜÖÈÉ®ÂàÜÈöîÁ∫ø
                for (let i = 1; i < 3; i++) {
                    const dividerX = x + (barWidth / 3) * i;
                    this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                    this.ctx.beginPath();
                    this.ctx.moveTo(dividerX, y);
                    this.ctx.lineTo(dividerX, y + barHeight);
                    this.ctx.stroke();
                }

                this.ctx.shadowBlur = 0;
            }

            drawBullet(bullet) {
                this.ctx.save();

                const time = Date.now() * 0.01;

                // ÁªòÂà∂ËÉΩÈáèÂ∞æËøπ
                const trailLength = 8;
                for (let i = 0; i < trailLength; i++) {
                    const alpha = (trailLength - i) / trailLength * 0.6;
                    const trailX = bullet.x - (bullet.vx / BULLET_SPEED) * i * 2;
                    const trailY = bullet.y - (bullet.vy / BULLET_SPEED) * i * 2;

                    this.ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(trailX, trailY, BULLET_SIZE / 2 * (1 - i / trailLength), 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // Â§ñÂ±ÇËÉΩÈáèÂú∫
                this.ctx.shadowColor = '#00ffff';
                this.ctx.shadowBlur = 10;

                const outerGradient = this.ctx.createRadialGradient(
                    bullet.x, bullet.y, 0,
                    bullet.x, bullet.y, BULLET_SIZE
                );
                outerGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                outerGradient.addColorStop(0.5, 'rgba(0, 255, 255, 0.6)');
                outerGradient.addColorStop(1, 'rgba(0, 255, 255, 0)');

                this.ctx.fillStyle = outerGradient;
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, BULLET_SIZE * 0.8, 0, Math.PI * 2);
                this.ctx.fill();

                // ÂÜÖÊ†∏
                const coreGradient = this.ctx.createRadialGradient(
                    bullet.x - 1, bullet.y - 1, 0,
                    bullet.x, bullet.y, BULLET_SIZE / 2
                );
                coreGradient.addColorStop(0, '#ffffff');
                coreGradient.addColorStop(0.3, '#88ffff');
                coreGradient.addColorStop(1, '#0088ff');

                this.ctx.fillStyle = coreGradient;
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, BULLET_SIZE / 2, 0, Math.PI * 2);
                this.ctx.fill();

                // ËÑâÂÜ≤ÁéØ
                this.ctx.strokeStyle = '#00ffff';
                this.ctx.lineWidth = 1;
                this.ctx.globalAlpha = 0.8 + Math.sin(time * 3) * 0.2;
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, BULLET_SIZE / 2 + 2, 0, Math.PI * 2);
                this.ctx.stroke();

                this.ctx.shadowBlur = 0;
                this.ctx.globalAlpha = 1;
                this.ctx.restore();
            }

            drawObstacle(obstacle) {
                this.ctx.save();

                const time = Date.now() * 0.002;

                // ÁªòÂà∂Â§ñÈÉ®ËÉΩÈáèÊä§Áõæ
                this.ctx.shadowColor = '#ff6600';
                this.ctx.shadowBlur = 8;

                const shieldGradient = this.ctx.createRadialGradient(
                    obstacle.x, obstacle.y, 0,
                    obstacle.x, obstacle.y, Math.max(obstacle.width, obstacle.height) * 0.7
                );
                shieldGradient.addColorStop(0, 'rgba(255, 102, 0, 0.1)');
                shieldGradient.addColorStop(0.8, 'rgba(255, 102, 0, 0.3)');
                shieldGradient.addColorStop(1, 'rgba(255, 102, 0, 0)');

                this.ctx.fillStyle = shieldGradient;
                if (obstacle.type === 'circle') {
                    this.ctx.beginPath();
                    this.ctx.arc(obstacle.x, obstacle.y, obstacle.width / 2 * 1.2, 0, Math.PI * 2);
                    this.ctx.fill();
                } else {
                    this.ctx.fillRect(
                        obstacle.x - obstacle.width / 2 * 1.2,
                        obstacle.y - obstacle.height / 2 * 1.2,
                        obstacle.width * 1.2,
                        obstacle.height * 1.2
                    );
                }

                // ÁªòÂà∂‰∏ª‰Ωì
                const mainGradient = this.ctx.createLinearGradient(
                    obstacle.x - obstacle.width / 2, obstacle.y - obstacle.height / 2,
                    obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2
                );
                mainGradient.addColorStop(0, '#1a237e');
                mainGradient.addColorStop(0.3, '#283593');
                mainGradient.addColorStop(0.7, '#3949ab');
                mainGradient.addColorStop(1, '#1a237e');

                this.ctx.fillStyle = mainGradient;

                if (obstacle.type === 'circle') {
                    this.ctx.beginPath();
                    this.ctx.arc(obstacle.x, obstacle.y, obstacle.width / 2, 0, Math.PI * 2);
                    this.ctx.fill();

                    // ËÉΩÈáèÁéØ
                    this.ctx.strokeStyle = '#ff6600';
                    this.ctx.lineWidth = 2;
                    this.ctx.globalAlpha = 0.6 + Math.sin(time * 3) * 0.3;
                    this.ctx.beginPath();
                    this.ctx.arc(obstacle.x, obstacle.y, obstacle.width / 2 + 3, 0, Math.PI * 2);
                    this.ctx.stroke();
                } else {
                    this.ctx.fillRect(
                        obstacle.x - obstacle.width / 2,
                        obstacle.y - obstacle.height / 2,
                        obstacle.width,
                        obstacle.height
                    );

                    // ËÉΩÈáèËæπÊ°Ü
                    this.ctx.strokeStyle = '#ff6600';
                    this.ctx.lineWidth = 2;
                    this.ctx.globalAlpha = 0.6 + Math.sin(time * 3) * 0.3;
                    this.ctx.strokeRect(
                        obstacle.x - obstacle.width / 2 - 2,
                        obstacle.y - obstacle.height / 2 - 2,
                        obstacle.width + 4,
                        obstacle.height + 4
                    );
                }

                // ÂÜÖÈÉ®ÁßëÊäÄÁ∫πÁêÜ
                this.ctx.globalAlpha = 0.4;
                this.ctx.strokeStyle = '#00ffff';
                this.ctx.lineWidth = 1;

                if (obstacle.type === 'circle') {
                    // ÂúÜÂΩ¢ÂÜÖÈÉ®ÁΩëÊ†º
                    const radius = obstacle.width / 2;
                    for (let i = 0; i < 4; i++) {
                        const angle = (i * Math.PI) / 2 + time;
                        this.ctx.beginPath();
                        this.ctx.moveTo(
                            obstacle.x + Math.cos(angle) * radius * 0.3,
                            obstacle.y + Math.sin(angle) * radius * 0.3
                        );
                        this.ctx.lineTo(
                            obstacle.x + Math.cos(angle) * radius * 0.8,
                            obstacle.y + Math.sin(angle) * radius * 0.8
                        );
                        this.ctx.stroke();
                    }
                } else {
                    // Áü©ÂΩ¢ÂÜÖÈÉ®ÁΩëÊ†º
                    const lines = 3;
                    for (let i = 1; i < lines; i++) {
                        const x = obstacle.x - obstacle.width / 2 + (obstacle.width / lines) * i;
                        const y = obstacle.y - obstacle.height / 2 + (obstacle.height / lines) * i;

                        this.ctx.beginPath();
                        this.ctx.moveTo(x, obstacle.y - obstacle.height / 2);
                        this.ctx.lineTo(x, obstacle.y + obstacle.height / 2);
                        this.ctx.stroke();

                        this.ctx.beginPath();
                        this.ctx.moveTo(obstacle.x - obstacle.width / 2, y);
                        this.ctx.lineTo(obstacle.x + obstacle.width / 2, y);
                        this.ctx.stroke();
                    }
                }

                this.ctx.shadowBlur = 0;
                this.ctx.globalAlpha = 1;
                this.ctx.restore();
            }

            drawAimingLine() {
                const myPlayer = this.model.players.get(this.viewId);
                if (!myPlayer || !this.model.gameStarted) return;

                this.ctx.save();

                // ÁûÑÂáÜÁ∫ø
                this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
                this.ctx.lineWidth = 2;
                this.ctx.shadowColor = '#00ffff';
                this.ctx.shadowBlur = 5;
                this.ctx.setLineDash([8, 4]);

                this.ctx.beginPath();
                this.ctx.moveTo(myPlayer.x, myPlayer.y);
                this.ctx.lineTo(this.mouseX, this.mouseY);
                this.ctx.stroke();

                // ÁûÑÂáÜÂô®
                this.ctx.setLineDash([]);
                this.ctx.strokeStyle = '#00ffff';
                this.ctx.lineWidth = 2;
                this.ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';

                // Â§ñÂúà
                this.ctx.beginPath();
                this.ctx.arc(this.mouseX, this.mouseY, 8, 0, Math.PI * 2);
                this.ctx.stroke();

                // ÂÜÖÂúà
                this.ctx.beginPath();
                this.ctx.arc(this.mouseX, this.mouseY, 3, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.stroke();

                // ÂçÅÂ≠óÂáÜÊòü
                this.ctx.beginPath();
                this.ctx.moveTo(this.mouseX - 12, this.mouseY);
                this.ctx.lineTo(this.mouseX - 8, this.mouseY);
                this.ctx.moveTo(this.mouseX + 8, this.mouseY);
                this.ctx.lineTo(this.mouseX + 12, this.mouseY);
                this.ctx.moveTo(this.mouseX, this.mouseY - 12);
                this.ctx.lineTo(this.mouseX, this.mouseY - 8);
                this.ctx.moveTo(this.mouseX, this.mouseY + 8);
                this.ctx.lineTo(this.mouseX, this.mouseY + 12);
                this.ctx.stroke();

                this.ctx.shadowBlur = 0;
                this.ctx.restore();
            }

            lightenColor(color, percent) {
                const num = parseInt(color.replace("#", ""), 16);
                const amt = Math.round(2.55 * percent * 100);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                    (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                    (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
            }
        }

        // ÂêØÂä®Ê∏∏Êàè
        Multisynq.App.makeWidgetDock();

        Multisynq.Session.join({
            apiKey: '2b599LeFw5HNytHLfolNXnHvK7VkXFdUm23jxmC2Z3',
            appId: 'io.multisynqchat.client',
            model: CandyBattleGame,
            view: CandyBattleView,
            viewData: {}
        }).then(session => {
            console.log('Ê∏∏ÊàèÂ∑≤ÂêØÂä®ÔºÅ', session);
        }).catch(error => {
            console.error('Ê∏∏ÊàèÂêØÂä®Â§±Ë¥•Ôºö', error);
        });
    </script>
</body>

</html>